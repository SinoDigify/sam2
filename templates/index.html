<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¹¦æ³•åˆ†å‰²å·¥å…·</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            background: #f0f2f5;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* å·¦ä¾§åˆ†å‰²åˆ—è¡¨ */
        .sidebar-left {
            width: 280px;
            background: white;
            border-right: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #408ade 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 20px;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 12px;
        }

        .status {
            padding: 10px 15px;
            background: #e7f3ff;
            border-bottom: 1px solid #b3d9ff;
            font-size: 12px;
            color: #0066cc;
        }

        .segments-container {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .segments-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 10px;
        }

        .segment-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .segment-item {
            position: relative;
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 8px;
            transition: all 0.2s;
        }

        .segment-item:hover {
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .segment-item img {
            width: 100%;
            height: auto;
            border-radius: 2px;
        }

        .segment-item .delete-btn {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(220, 53, 69, 0.9);
            color: white;
            border: none;
            border-radius: 3px;
            padding: 4px 8px;
            font-size: 11px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .segment-item:hover .delete-btn {
            opacity: 1;
        }

        .segment-id {
            text-align: center;
            font-size: 11px;
            color: #666;
            margin-top: 4px;
        }

        /* ä¸­é—´ç”»å¸ƒåŒºåŸŸ */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #fafafa;
        }

        .toolbar {
            background: white;
            padding: 12px 20px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: auto;
            background: #fafafa;
        }

        .canvas-container {
            min-width: 100%;
            min-height: 100%;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            box-sizing: border-box;
        }

        .canvas-layers {
            position: relative;
        }

        #canvas {
            cursor: crosshair;
            border: 1px solid #ddd;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: block;
        }

        #gridCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        .selection-box {
            position: absolute;
            border: 2px solid #667eea;
            background: rgba(102, 126, 234, 0.15);
            pointer-events: none;
            box-shadow: 0 0 0 1px rgba(255, 255, 255, 0.5);
            z-index: 20;
        }

        .selection-size {
            position: absolute;
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            pointer-events: none;
            white-space: nowrap;
            z-index: 21;
        }

        .crosshair-h, .crosshair-v {
            position: absolute;
            background: rgba(255, 0, 0, 0.5);
            pointer-events: none;
            z-index: 15;
        }

        .crosshair-h {
            height: 1px;
            left: 0;
            right: 0;
        }

        .crosshair-v {
            width: 1px;
            top: 0;
            bottom: 0;
        }

        .instructions {
            background: white;
            padding: 15px 20px;
            border-top: 1px solid #e0e0e0;
            font-size: 12px;
        }

        .instructions strong {
            color: #667eea;
        }

        /* å³ä¾§æ§åˆ¶é¢æ¿ */
        .sidebar-right {
            width: 360px;
            background: white;
            border-left: 1px solid #e0e0e0;
            display: flex;
            flex-direction: column;
            transition: width 0.3s;
        }

        .sidebar-right.collapsed {
            width: 50px;
        }

        .sidebar-right.collapsed .panel-content {
            display: none;
        }

        .sidebar-right.collapsed .toggle-btn {
            transform: rotate(180deg);
        }

        .panel-header {
            background: #f8f9fa;
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
        }

        .toggle-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 18px;
            color: #666;
            transition: transform 0.3s;
            padding: 5px;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }

        .section {
            margin-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
            padding-bottom: 15px;
            cursor: pointer;
        }

        .section:last-child {
            border-bottom: none;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            background: #f8f9fa;
            border-radius: 4px;
            margin-bottom: 10px;
            user-select: none;
            transition: background 0.2s;
        }

        .section:hover .section-header {
            background: #e9ecef;
        }

        .section-title {
            font-size: 13px;
            font-weight: 600;
            color: #333;
        }

        .collapse-icon {
            font-size: 12px;
            color: #666;
            transition: transform 0.2s;
        }

        .section.collapsed .collapse-icon {
            transform: rotate(-90deg);
        }

        .section.collapsed .section-body {
            display: none;
        }

        .section-body {
            padding: 10px 0;
        }

        .control-group {
            margin-bottom: 12px;
        }

        .control-group label {
            display: block;
            font-size: 11px;
            font-weight: 600;
            color: #666;
            margin-bottom: 5px;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .control-value {
            display: inline-block;
            min-width: 50px;
            text-align: right;
            font-size: 12px;
            color: #666;
        }

        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #545b62;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-reset {
            background: #17a2b8;
            color: white;
        }

        .btn-reset:hover {
            background: #138496;
        }

        .zoom-controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .zoom-level {
            font-size: 12px;
            color: #666;
            min-width: 60px;
            text-align: center;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 5px;
        }

        .checkbox-group input[type="checkbox"] {
            cursor: pointer;
        }

        .checkbox-group label {
            font-size: 12px;
            font-weight: normal;
            cursor: pointer;
            margin: 0;
        }

        .theme-presets {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .theme-btn {
            padding: 8px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: left;
        }

        .theme-btn:hover {
            background: #f0f0f0;
            border-color: #667eea;
        }

        .theme-btn.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .theme-name {
            font-weight: 600;
            display: block;
            margin-bottom: 2px;
        }

        .theme-desc {
            font-size: 10px;
            opacity: 0.8;
        }

        .curve-canvas {
            width: 100%;
            height: 150px;
            border: 1px solid #e0e0e0;
            cursor: crosshair;
            display: block;
            border-radius: 4px;
        }

        .curve-presets {
            display: flex;
            gap: 5px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .curve-preset-btn {
            padding: 4px 8px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 3px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .curve-preset-btn:hover {
            background: #f0f0f0;
            border-color: #667eea;
        }

        .comparison-container {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .comparison-item {
            flex: 1;
            text-align: center;
        }

        .comparison-item canvas {
            width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .comparison-label {
            font-size: 10px;
            color: #666;
            margin-top: 5px;
        }

        .save-config-btn {
            width: 100%;
            margin-top: 15px;
        }

        /* ç¼©ç•¥å›¾å¯¼èˆª */
        .minimap {
            position: fixed;
            background: white;
            border: 2px solid #667eea;
            border-radius: 4px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            cursor: move;
            z-index: 1000;
            user-select: none;
        }

        .minimap-header {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            font-size: 10px;
            font-weight: 600;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }

        .minimap-close {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 14px;
            padding: 0;
            width: 16px;
            height: 16px;
            line-height: 14px;
        }

        .minimap-canvas-wrapper {
            position: relative;
            padding: 4px;
        }

        .minimap-canvas {
            display: block;
            max-width: 200px;
            max-height: 200px;
        }

        .minimap-viewport {
            position: absolute;
            border: 2px solid #ff6b6b;
            background: rgba(255, 107, 107, 0.2);
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- å·¦ä¾§åˆ†å‰²åˆ—è¡¨ -->
    <div class="sidebar-left">
        <div class="header">
            <h1>ğŸ–¼ï¸ ä¹¦æ³•åˆ†å‰²å·¥å…·</h1>
            <p>æ¡†é€‰è‡ªåŠ¨åˆ†å‰² Â· ä¸“ä¸šå·¥å…·</p>
        </div>

        <div class="status" id="statusText">åŠ è½½ä¸­...</div>

        <div class="segments-container">
            <div class="segments-title">
                ğŸ“¦ å·²åˆ†å‰²æ±‰å­— (<span id="segmentCount">0</span>)
            </div>
            <div class="segment-grid" id="segmentGrid"></div>
        </div>
    </div>

    <!-- ä¸­é—´ç”»å¸ƒåŒºåŸŸ -->
    <div class="main-content">
        <div class="toolbar">
            <div style="font-size: 14px; font-weight: 600;">ğŸ“ æ¡†é€‰åŒºåŸŸ (æœ€å° 100Ã—100)</div>
            <button class="btn btn-secondary" onclick="toggleMinimap()">ğŸ—ºï¸ å¯¼èˆª</button>
        </div>

        <div class="canvas-wrapper" id="canvasWrapper">
            <div class="canvas-container" id="canvasContainer">
                <div class="canvas-layers">
                    <canvas id="canvas"></canvas>
                    <canvas id="gridCanvas"></canvas>
                    <div class="crosshair-h" id="crosshairH" style="display: none;"></div>
                    <div class="crosshair-v" id="crosshairV" style="display: none;"></div>
                </div>
            </div>
        </div>

        <div class="instructions">
            <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong>
            æ¡†é€‰æ±‰å­— (â‰¥100Ã—100) â†’ è‡ªåŠ¨åˆ†å‰²ä¿å­˜ â†’ ä½¿ç”¨å³ä¾§å·¥å…·è°ƒæ•´å›¾åƒ
        </div>
    </div>

    <!-- å³ä¾§æ§åˆ¶é¢æ¿ -->
    <div class="sidebar-right" id="sidebarRight">
        <div class="panel-header">
            <span class="panel-title">âš™ï¸ æ§åˆ¶é¢æ¿</span>
            <button class="toggle-btn" onclick="togglePanel()">â—€</button>
        </div>

        <div class="panel-content">
            <!-- ä¸»é¢˜é¢„è®¾ -->
            <div class="section" onclick="toggleSection(this)">
                <div class="section-header">
                    <span class="section-title">ğŸ¨ ä¸»é¢˜é¢„è®¾</span>
                    <span class="collapse-icon">â–¼</span>
                </div>
                <div class="section-body" onclick="event.stopPropagation()">
                    <div class="theme-presets">
                        <button class="theme-btn" onclick="applyTheme('default')">
                            <span class="theme-name">é»˜è®¤</span>
                            <span class="theme-desc">åŸå§‹è®¾ç½®</span>
                        </button>
                        <button class="theme-btn" onclick="applyTheme('bright')">
                            <span class="theme-name">æ˜äº®</span>
                            <span class="theme-desc">æäº®å¯¹æ¯”</span>
                        </button>
                        <button class="theme-btn" onclick="applyTheme('dark')">
                            <span class="theme-name">æ·±è‰²</span>
                            <span class="theme-desc">å‹æš—ç»†èŠ‚</span>
                        </button>
                        <button class="theme-btn" onclick="applyTheme('highcontrast')">
                            <span class="theme-name">é«˜å¯¹æ¯”</span>
                            <span class="theme-desc">å¼ºåŒ–å¯¹æ¯”</span>
                        </button>
                        <button class="theme-btn" onclick="applyTheme('ink')">
                            <span class="theme-name">æ°´å¢¨</span>
                            <span class="theme-desc">åè‰²æ°´å¢¨</span>
                        </button>
                        <button class="theme-btn" onclick="applyTheme('soft')">
                            <span class="theme-name">æŸ”å’Œ</span>
                            <span class="theme-desc">ä½é¥±å’Œåº¦</span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- ç¼©æ”¾æ§åˆ¶ -->
            <div class="section collapsed" onclick="toggleSection(this)">
                <div class="section-header">
                    <span class="section-title">ğŸ” ç¼©æ”¾æ§åˆ¶</span>
                    <span class="collapse-icon">â–¼</span>
                </div>
                <div class="section-body" onclick="event.stopPropagation()">
                    <div class="zoom-controls">
                        <button class="btn btn-secondary" onclick="zoomOut()" style="flex: 1;">âˆ’</button>
                        <span class="zoom-level" id="zoomLevel">100%</span>
                        <button class="btn btn-secondary" onclick="zoomIn()" style="flex: 1;">+</button>
                        <button class="btn btn-secondary" onclick="resetZoom()" style="flex: 1;">é‡ç½®</button>
                    </div>
                </div>
            </div>

            <!-- ç½‘æ ¼å‚è€ƒçº¿ -->
            <div class="section collapsed" onclick="toggleSection(this)">
                <div class="section-header">
                    <span class="section-title">ğŸ“ ç½‘æ ¼å‚è€ƒçº¿</span>
                    <span class="collapse-icon">â–¼</span>
                </div>
                <div class="section-body" onclick="event.stopPropagation()">
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGrid" onchange="toggleGrid()">
                        <label for="showGrid">æ˜¾ç¤ºç½‘æ ¼</label>
                    </div>
                    <div class="control-group" style="margin-top: 10px;">
                        <label>ç½‘æ ¼é—´è·: <span class="control-value" id="gridSizeValue">50</span>px</label>
                        <input type="range" id="gridSize" min="20" max="200" value="50" oninput="updateGridSize(this.value)" disabled>
                    </div>
                </div>
            </div>

            <!-- å›¾åƒè°ƒæ•´ -->
            <div class="section collapsed" onclick="toggleSection(this)">
                <div class="section-header">
                    <span class="section-title">ğŸ¨ å›¾åƒè°ƒæ•´</span>
                    <span class="collapse-icon">â–¼</span>
                </div>
                <div class="section-body" onclick="event.stopPropagation()">
                    <div class="control-group">
                        <label>äº®åº¦: <span class="control-value" id="brightnessValue">100</span>%</label>
                        <input type="range" id="brightness" min="0" max="200" value="100" oninput="updateImageAdjustments()">
                    </div>
                    <div class="control-group">
                        <label>å¯¹æ¯”åº¦: <span class="control-value" id="contrastValue">100</span>%</label>
                        <input type="range" id="contrast" min="0" max="200" value="100" oninput="updateImageAdjustments()">
                    </div>
                    <div class="control-group">
                        <label>é¥±å’Œåº¦: <span class="control-value" id="saturationValue">100</span>%</label>
                        <input type="range" id="saturation" min="0" max="200" value="100" oninput="updateImageAdjustments()">
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="invertColors" onchange="updateImageAdjustments()">
                        <label for="invertColors">ğŸ”„ åè‰²</label>
                    </div>

                    <!-- å¯¹æ¯”é¢„è§ˆ -->
                    <div class="comparison-container">
                        <div class="comparison-item">
                            <canvas id="previewOriginal" width="120" height="120"></canvas>
                            <div class="comparison-label">åŸå§‹</div>
                        </div>
                        <div class="comparison-item">
                            <canvas id="previewAdjusted" width="120" height="120"></canvas>
                            <div class="comparison-label">è°ƒæ•´å</div>
                        </div>
                    </div>

                    <button class="btn btn-reset" onclick="resetAdjustments()" style="width: 100%; margin-top: 10px;">é‡ç½®è°ƒæ•´</button>
                </div>
            </div>

            <!-- æ›²çº¿è°ƒæ•´ -->
            <div class="section collapsed" onclick="toggleSection(this)">
                <div class="section-header">
                    <span class="section-title">ğŸ“ˆ æ›²çº¿è°ƒæ•´</span>
                    <span class="collapse-icon">â–¼</span>
                </div>
                <div class="section-body" onclick="event.stopPropagation()">
                    <canvas id="curveCanvas" class="curve-canvas" width="256" height="150"></canvas>
                    <div class="curve-presets">
                        <button class="curve-preset-btn" onclick="applyCurvePreset('linear')">çº¿æ€§</button>
                        <button class="curve-preset-btn" onclick="applyCurvePreset('increase')">æäº®</button>
                        <button class="curve-preset-btn" onclick="applyCurvePreset('decrease')">å‹æš—</button>
                        <button class="curve-preset-btn" onclick="applyCurvePreset('contrast')">é«˜å¯¹æ¯”</button>
                        <button class="curve-preset-btn" onclick="applyCurvePreset('sshape')">Sæ›²çº¿</button>
                    </div>
                </div>
            </div>

            <!-- ä¿å­˜é…ç½®æŒ‰é’® -->
            <button class="btn btn-success save-config-btn" onclick="saveConfigToServer()">ğŸ’¾ ä¿å­˜é…ç½®åˆ°æœåŠ¡å™¨</button>
        </div>
    </div>

    <!-- ç¼©ç•¥å›¾å¯¼èˆªï¼ˆå…¨å±€æµ®åŠ¨ï¼‰ -->
    <div class="minimap" id="minimap" style="display: none;">
        <div class="minimap-header" id="minimapHeader">
            <span>å¯¼èˆª</span>
            <button class="minimap-close" onclick="toggleMinimap()">Ã—</button>
        </div>
        <div class="minimap-canvas-wrapper">
            <canvas id="minimapCanvas" class="minimap-canvas"></canvas>
            <div class="minimap-viewport" id="minimapViewport"></div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const gridCanvas = document.getElementById('gridCanvas');
        const gridCtx = gridCanvas.getContext('2d');
        const previewOriginal = document.getElementById('previewOriginal');
        const previewAdjusted = document.getElementById('previewAdjusted');
        const previewOriginalCtx = previewOriginal.getContext('2d');
        const previewAdjustedCtx = previewAdjusted.getContext('2d');
        const curveCanvas = document.getElementById('curveCanvas');
        const curveCtx = curveCanvas.getContext('2d');

        const canvasContainer = document.getElementById('canvasContainer');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const statusText = document.getElementById('statusText');
        const segmentCount = document.getElementById('segmentCount');
        const segmentGrid = document.getElementById('segmentGrid');
        const zoomLevelText = document.getElementById('zoomLevel');
        const crosshairH = document.getElementById('crosshairH');
        const crosshairV = document.getElementById('crosshairV');

        // ç¼©ç•¥å›¾ç›¸å…³å…ƒç´ 
        const minimap = document.getElementById('minimap');
        const minimapCanvas = document.getElementById('minimapCanvas');
        const minimapCtx = minimapCanvas.getContext('2d');
        const minimapViewport = document.getElementById('minimapViewport');
        const minimapHeader = document.getElementById('minimapHeader');

        let originalImage = null;
        let scale = 1;
        let isDragging = false;
        let startX, startY;
        let selectionBox = null;
        let selectionSizeLabel = null;

        // ç¼©ç•¥å›¾æ‹–åŠ¨
        let isMinimapDragging = false;
        let minimapDragOffsetX = 0;
        let minimapDragOffsetY = 0;

        // å›¾åƒè°ƒæ•´å‚æ•°
        let brightness = 100;
        let contrast = 100;
        let saturation = 100;
        let invertColors = false;
        let showGrid = false;
        let gridSize = 50;

        // æ›²çº¿è°ƒæ•´å‚æ•°
        let curvePoints = [{x: 0, y: 0}, {x: 255, y: 255}];
        let curveLUT = new Array(256);
        let selectedPoint = null;
        let isDraggingCurve = false;

        const MIN_SELECTION_SIZE = 100;

        // ä¸»é¢˜é¢„è®¾
        const themes = {
            'default': {
                brightness: 100,
                contrast: 100,
                saturation: 100,
                invert_colors: false,
                curve_points: [{x: 0, y: 0}, {x: 255, y: 255}]
            },
            'bright': {
                brightness: 130,
                contrast: 110,
                saturation: 105,
                invert_colors: false,
                curve_points: [{x: 0, y: 30}, {x: 255, y: 255}]
            },
            'dark': {
                brightness: 80,
                contrast: 120,
                saturation: 95,
                invert_colors: false,
                curve_points: [{x: 0, y: 0}, {x: 255, y: 225}]
            },
            'highcontrast': {
                brightness: 100,
                contrast: 150,
                saturation: 100,
                invert_colors: false,
                curve_points: [{x: 0, y: 20}, {x: 128, y: 128}, {x: 255, y: 235}]
            },
            'ink': {
                brightness: 110,
                contrast: 130,
                saturation: 0,
                invert_colors: true,
                curve_points: [{x: 0, y: 0}, {x: 255, y: 255}]
            },
            'soft': {
                brightness: 105,
                contrast: 95,
                saturation: 70,
                invert_colors: false,
                curve_points: [{x: 0, y: 10}, {x: 255, y: 245}]
            }
        };

        // åˆ‡æ¢é¢æ¿
        function togglePanel() {
            document.getElementById('sidebarRight').classList.toggle('collapsed');
        }

        // åˆ‡æ¢æŠ˜å åŒºåŸŸ
        function toggleSection(element) {
            // å¦‚æœç‚¹å‡»çš„æ˜¯ section å…ƒç´ æœ¬èº«ï¼Œä½¿ç”¨å®ƒï¼›å¦åˆ™æ‰¾åˆ°çˆ¶ section
            const section = element.classList.contains('section') ? element : element.closest('.section');
            if (section) {
                section.classList.toggle('collapsed');
            }
        }

        // åº”ç”¨ä¸»é¢˜
        function applyTheme(themeName) {
            const theme = themes[themeName];
            if (!theme) return;

            brightness = theme.brightness;
            contrast = theme.contrast;
            saturation = theme.saturation;
            invertColors = theme.invert_colors;
            curvePoints = JSON.parse(JSON.stringify(theme.curve_points));

            // æ›´æ–° UI
            document.getElementById('brightness').value = brightness;
            document.getElementById('contrast').value = contrast;
            document.getElementById('saturation').value = saturation;
            document.getElementById('invertColors').checked = invertColors;
            document.getElementById('brightnessValue').textContent = brightness;
            document.getElementById('contrastValue').textContent = contrast;
            document.getElementById('saturationValue').textContent = saturation;

            updateCurveLUT();
            redrawCanvas();
            updatePreview();

            // æ›´æ–°ä¸»é¢˜æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.theme-btn').forEach(btn => btn.classList.remove('active'));
            event.target.closest('.theme-btn').classList.add('active');
        }

        // åŠ è½½å›¾åƒ
        async function loadImage() {
            try {
                const response = await fetch('/get_image');
                const data = await response.json();

                originalImage = new Image();
                originalImage.onload = () => {
                    canvas.width = originalImage.width;
                    canvas.height = originalImage.height;
                    gridCanvas.width = originalImage.width;
                    gridCanvas.height = originalImage.height;

                    redrawCanvas();
                    updatePreview();
                    updateMinimap();
                    statusText.textContent = 'âœ… å°±ç»ª - æ¡†é€‰æ±‰å­—å¼€å§‹åˆ†å‰² (æœ€å° 100Ã—100)';
                    loadSavedSegments();
                    loadConfig();  // åŠ è½½ä¿å­˜çš„é…ç½®
                };
                originalImage.src = data.image;
            } catch (error) {
                console.error('åŠ è½½å›¾åƒå¤±è´¥:', error);
                statusText.textContent = 'âŒ åŠ è½½å¤±è´¥';
            }
        }

        // åŠ è½½é…ç½®
        async function loadConfig() {
            try {
                const response = await fetch('/get_config');
                const config = await response.json();

                brightness = config.brightness !== undefined ? config.brightness : 100;
                contrast = config.contrast !== undefined ? config.contrast : 100;
                saturation = config.saturation !== undefined ? config.saturation : 100;
                invertColors = config.invert_colors || false;

                document.getElementById('brightness').value = brightness;
                document.getElementById('contrast').value = contrast;
                document.getElementById('saturation').value = saturation;
                document.getElementById('invertColors').checked = invertColors;
                document.getElementById('brightnessValue').textContent = brightness;
                document.getElementById('contrastValue').textContent = contrast;
                document.getElementById('saturationValue').textContent = saturation;

                if (config.curve_points && config.curve_points.length > 0) {
                    curvePoints = config.curve_points;
                    updateCurveLUT();
                }

                redrawCanvas();
                updatePreview();
            } catch (error) {
                console.error('åŠ è½½é…ç½®å¤±è´¥:', error);
            }
        }

        // ä¿å­˜é…ç½®åˆ°æœåŠ¡å™¨ï¼ˆä»…åœ¨ç‚¹å‡»æŒ‰é’®æ—¶è°ƒç”¨ï¼‰
        async function saveConfigToServer() {
            try {
                const config = {
                    brightness: parseInt(brightness),
                    contrast: parseInt(contrast),
                    saturation: parseInt(saturation),
                    invert_colors: invertColors,
                    curve_points: curvePoints
                };

                const response = await fetch('/save_config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });

                if (response.ok) {
                    statusText.textContent = 'âœ… é…ç½®å·²ä¿å­˜';
                    setTimeout(() => {
                        statusText.textContent = 'âœ… å°±ç»ª - æ¡†é€‰æ±‰å­—å¼€å§‹åˆ†å‰² (æœ€å° 100Ã—100)';
                    }, 2000);
                }
            } catch (error) {
                console.error('ä¿å­˜é…ç½®å¤±è´¥:', error);
                statusText.textContent = 'âŒ ä¿å­˜é…ç½®å¤±è´¥';
            }
        }

        // æ›´æ–°é¢„è§ˆ
        function updatePreview() {
            if (!originalImage) return;

            const size = 120;
            const scale = Math.min(size / originalImage.width, size / originalImage.height);
            const w = originalImage.width * scale;
            const h = originalImage.height * scale;
            const x = (size - w) / 2;
            const y = (size - h) / 2;

            // åŸå§‹é¢„è§ˆ
            previewOriginalCtx.fillStyle = '#f0f0f0';
            previewOriginalCtx.fillRect(0, 0, size, size);
            previewOriginalCtx.drawImage(originalImage, x, y, w, h);

            // è°ƒæ•´åé¢„è§ˆ
            previewAdjustedCtx.fillStyle = '#f0f0f0';
            previewAdjustedCtx.fillRect(0, 0, size, size);
            previewAdjustedCtx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%)`;
            previewAdjustedCtx.drawImage(originalImage, x, y, w, h);
            previewAdjustedCtx.filter = 'none';

            applyCurveToCanvas(previewAdjustedCtx, size, size);
        }

        // é‡ç»˜ç”»å¸ƒ
        function redrawCanvas() {
            if (!originalImage) return;

            const displayWidth = canvas.width * scale;
            const displayHeight = canvas.height * scale;

            const canvasLayers = document.querySelector('.canvas-layers');
            canvasLayers.style.width = displayWidth + 'px';
            canvasLayers.style.height = displayHeight + 'px';

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.filter = `brightness(${brightness}%) contrast(${contrast}%) saturate(${saturation}%)`;
            ctx.drawImage(originalImage, 0, 0);
            ctx.filter = 'none';

            applyCurveToCanvas(ctx, canvas.width, canvas.height);
            drawGrid();
        }

        // ç»˜åˆ¶ç½‘æ ¼
        function drawGrid() {
            gridCtx.clearRect(0, 0, gridCanvas.width, gridCanvas.height);

            if (!showGrid) return;

            gridCtx.strokeStyle = 'rgba(102, 126, 234, 0.5)';
            gridCtx.lineWidth = 1;

            for (let x = 0; x < gridCanvas.width; x += gridSize) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, gridCanvas.height);
                gridCtx.stroke();
            }

            for (let y = 0; y < gridCanvas.height; y += gridSize) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(gridCanvas.width, y);
                gridCtx.stroke();
            }
        }

        // æ›´æ–°å›¾åƒè°ƒæ•´
        function updateImageAdjustments() {
            brightness = document.getElementById('brightness').value;
            contrast = document.getElementById('contrast').value;
            saturation = document.getElementById('saturation').value;
            invertColors = document.getElementById('invertColors').checked;

            document.getElementById('brightnessValue').textContent = brightness;
            document.getElementById('contrastValue').textContent = contrast;
            document.getElementById('saturationValue').textContent = saturation;

            redrawCanvas();
            updatePreview();
        }

        // é‡ç½®è°ƒæ•´
        function resetAdjustments() {
            applyTheme('default');
        }

        // åº”ç”¨æ›²çº¿è°ƒæ•´åˆ°ç”»å¸ƒ
        function applyCurveToCanvas(context, width, height) {
            const imageData = context.getImageData(0, 0, width, height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = curveLUT[data[i]];
                data[i + 1] = curveLUT[data[i + 1]];
                data[i + 2] = curveLUT[data[i + 2]];
            }

            if (invertColors) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = 255 - data[i];
                    data[i + 1] = 255 - data[i + 1];
                    data[i + 2] = 255 - data[i + 2];
                }
            }

            context.putImageData(imageData, 0, 0);
        }

        // åˆ‡æ¢ç½‘æ ¼
        function toggleGrid() {
            showGrid = document.getElementById('showGrid').checked;
            document.getElementById('gridSize').disabled = !showGrid;
            drawGrid();
        }

        // æ›´æ–°ç½‘æ ¼å¤§å°
        function updateGridSize(value) {
            gridSize = parseInt(value);
            document.getElementById('gridSizeValue').textContent = gridSize;
            drawGrid();
        }

        // ç¼©æ”¾æ§åˆ¶
        function zoomIn() {
            const oldScale = scale;
            scale = Math.min(scale + 0.25, 3);
            updateZoom(oldScale);
        }

        function zoomOut() {
            const oldScale = scale;
            scale = Math.max(scale - 0.25, 0.25);
            updateZoom(oldScale);
        }

        function resetZoom() {
            const oldScale = scale;
            scale = 1;
            updateZoom(oldScale);
        }

        function updateZoom(oldScale) {
            const wrapper = canvasWrapper;
            const scrollLeft = wrapper.scrollLeft;
            const scrollTop = wrapper.scrollTop;
            const viewportCenterX = scrollLeft + wrapper.clientWidth / 2;
            const viewportCenterY = scrollTop + wrapper.clientHeight / 2;

            const oldWidth = canvas.width * oldScale;
            const oldHeight = canvas.height * oldScale;
            const centerX = viewportCenterX / oldWidth;
            const centerY = viewportCenterY / oldHeight;

            zoomLevelText.textContent = Math.round(scale * 100) + '%';
            redrawCanvas();

            const newWidth = canvas.width * scale;
            const newHeight = canvas.height * scale;
            wrapper.scrollLeft = centerX * newWidth - wrapper.clientWidth / 2;
            wrapper.scrollTop = centerY * newHeight - wrapper.clientHeight / 2;

            updateMinimapViewport();
        }

        // é¼ æ ‡äº‹ä»¶
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                updateSelection(e);
            } else {
                updateCrosshair(e);
            }
        });

        canvas.addEventListener('mouseenter', () => {
            crosshairH.style.display = 'block';
            crosshairV.style.display = 'block';
        });

        canvas.addEventListener('mouseleave', () => {
            crosshairH.style.display = 'none';
            crosshairV.style.display = 'none';
        });

        function updateCrosshair(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            crosshairH.style.top = y + 'px';
            crosshairV.style.left = x + 'px';
        }

        function updateSelection(e) {
            if (!selectionBox) return;

            const rect = canvas.getBoundingClientRect();
            const currentX = (e.clientX - rect.left) / scale;
            const currentY = (e.clientY - rect.top) / scale;

            const width = Math.abs(currentX - startX);
            const height = Math.abs(currentY - startY);
            const left = Math.min(startX, currentX);
            const top = Math.min(startY, currentY);

            selectionBox.style.left = (left * scale) + 'px';
            selectionBox.style.top = (top * scale) + 'px';
            selectionBox.style.width = (width * scale) + 'px';
            selectionBox.style.height = (height * scale) + 'px';

            const isValid = width >= MIN_SELECTION_SIZE && height >= MIN_SELECTION_SIZE;
            selectionSizeLabel.textContent = `${Math.round(width)} Ã— ${Math.round(height)}`;
            selectionSizeLabel.style.background = isValid ? 'rgba(40, 167, 69, 0.9)' : 'rgba(220, 53, 69, 0.9)';
            selectionSizeLabel.style.left = (left * scale) + 'px';
            selectionSizeLabel.style.top = (top * scale - 20) + 'px';
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            startX = (e.clientX - rect.left) / scale;
            startY = (e.clientY - rect.top) / scale;
            isDragging = true;

            crosshairH.style.display = 'none';
            crosshairV.style.display = 'none';

            const canvasLayers = document.querySelector('.canvas-layers');

            selectionBox = document.createElement('div');
            selectionBox.className = 'selection-box';
            selectionBox.style.left = (startX * scale) + 'px';
            selectionBox.style.top = (startY * scale) + 'px';
            canvasLayers.appendChild(selectionBox);

            selectionSizeLabel = document.createElement('div');
            selectionSizeLabel.className = 'selection-size';
            selectionSizeLabel.textContent = '0 Ã— 0';
            canvasLayers.appendChild(selectionSizeLabel);
        });

        canvas.addEventListener('mouseup', async (e) => {
            if (!isDragging) return;
            isDragging = false;

            const rect = canvas.getBoundingClientRect();
            const endX = (e.clientX - rect.left) / scale;
            const endY = (e.clientY - rect.top) / scale;

            const x1 = Math.min(startX, endX);
            const y1 = Math.min(startY, endY);
            const x2 = Math.max(startX, endX);
            const y2 = Math.max(startY, endY);

            const width = x2 - x1;
            const height = y2 - y1;

            if (selectionBox) {
                selectionBox.remove();
                selectionBox = null;
            }
            if (selectionSizeLabel) {
                selectionSizeLabel.remove();
                selectionSizeLabel = null;
            }

            crosshairH.style.display = 'block';
            crosshairV.style.display = 'block';

            if (width < MIN_SELECTION_SIZE || height < MIN_SELECTION_SIZE) {
                statusText.textContent = `âŒ é€‰åŒºå¤ªå° (${Math.round(width)}Ã—${Math.round(height)})ï¼Œéœ€è¦è‡³å°‘ ${MIN_SELECTION_SIZE}Ã—${MIN_SELECTION_SIZE}`;
                return;
            }

            statusText.textContent = 'â³ åˆ†å‰²ä¸­...';

            try {
                const response = await fetch('/predict_box', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        box: [x1, y1, x2, y2],
                        brightness: brightness,
                        contrast: contrast,
                        saturation: saturation,
                        curve_lut: curveLUT,
                        invert_colors: invertColors
                    })
                });

                const data = await response.json();

                if (data.success) {
                    statusText.textContent = `âœ… å·²ä¿å­˜ (å¾—åˆ†: ${data.score.toFixed(3)}, ${Math.round(width)}Ã—${Math.round(height)})`;
                    addSegmentToGrid(data);
                } else {
                    statusText.textContent = 'âŒ åˆ†å‰²å¤±è´¥';
                }
            } catch (error) {
                console.error('é¢„æµ‹å¤±è´¥:', error);
                statusText.textContent = 'âŒ é¢„æµ‹å¤±è´¥';
            }
        });

        function addSegmentToGrid(data) {
            const item = document.createElement('div');
            item.className = 'segment-item';
            item.innerHTML = `
                <img src="${data.segment_image}" alt="Segment ${data.count}">
                <button class="delete-btn" onclick="deleteSegment(${data.count - 1})">åˆ é™¤</button>
                <div class="segment-id">#${data.count - 1}</div>
            `;
            segmentGrid.insertBefore(item, segmentGrid.firstChild);
            segmentCount.textContent = data.count;
        }

        async function loadSavedSegments() {
            try {
                const response = await fetch('/get_saved_segments');
                const data = await response.json();

                segmentGrid.innerHTML = '';
                data.segments.forEach(seg => {
                    const item = document.createElement('div');
                    item.className = 'segment-item';
                    item.innerHTML = `
                        <img src="${seg.image}" alt="Segment ${seg.id}">
                        <button class="delete-btn" onclick="deleteSegment(${seg.id})">åˆ é™¤</button>
                        <div class="segment-id">#${seg.id}</div>
                    `;
                    segmentGrid.appendChild(item);
                });

                segmentCount.textContent = data.count;
            } catch (error) {
                console.error('åŠ è½½åˆ†å‰²å¤±è´¥:', error);
            }
        }

        async function deleteSegment(id) {
            if (!confirm('ç¡®å®šè¦åˆ é™¤è¿™ä¸ªåˆ†å‰²å—ï¼Ÿ')) return;

            try {
                const response = await fetch(`/delete_segment/${id}`, {
                    method: 'DELETE'
                });

                if (response.ok) {
                    loadSavedSegments();
                }
            } catch (error) {
                console.error('åˆ é™¤å¤±è´¥:', error);
            }
        }

        // ===== æ›²çº¿è°ƒæ•´åŠŸèƒ½ =====

        function updateCurveLUT() {
            curvePoints.sort((a, b) => a.x - b.x);

            for (let i = 0; i < 256; i++) {
                let value = i;

                for (let j = 0; j < curvePoints.length - 1; j++) {
                    const p1 = curvePoints[j];
                    const p2 = curvePoints[j + 1];

                    if (i >= p1.x && i <= p2.x) {
                        const t = (i - p1.x) / (p2.x - p1.x);
                        value = p1.y + t * (p2.y - p1.y);
                        break;
                    }
                }

                curveLUT[i] = Math.max(0, Math.min(255, Math.round(value)));
            }

            drawCurve();
            redrawCanvas();
            updatePreview();
        }

        function drawCurve() {
            const w = curveCanvas.width;
            const h = curveCanvas.height;

            curveCtx.fillStyle = '#f8f9fa';
            curveCtx.fillRect(0, 0, w, h);

            curveCtx.strokeStyle = '#e0e0e0';
            curveCtx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const x = (w * i) / 4;
                const y = (h * i) / 4;
                curveCtx.beginPath();
                curveCtx.moveTo(x, 0);
                curveCtx.lineTo(x, h);
                curveCtx.stroke();
                curveCtx.beginPath();
                curveCtx.moveTo(0, y);
                curveCtx.lineTo(w, y);
                curveCtx.stroke();
            }

            curveCtx.strokeStyle = '#ccc';
            curveCtx.setLineDash([5, 5]);
            curveCtx.beginPath();
            curveCtx.moveTo(0, h);
            curveCtx.lineTo(w, 0);
            curveCtx.stroke();
            curveCtx.setLineDash([]);

            curveCtx.strokeStyle = '#667eea';
            curveCtx.lineWidth = 2;
            curveCtx.beginPath();
            for (let i = 0; i < 256; i++) {
                const x = (i / 255) * w;
                const y = h - (curveLUT[i] / 255) * h;
                if (i === 0) {
                    curveCtx.moveTo(x, y);
                } else {
                    curveCtx.lineTo(x, y);
                }
            }
            curveCtx.stroke();

            curvePoints.forEach((p, idx) => {
                const x = (p.x / 255) * w;
                const y = h - (p.y / 255) * h;

                curveCtx.fillStyle = selectedPoint === idx ? '#ff6b6b' : '#667eea';
                curveCtx.beginPath();
                curveCtx.arc(x, y, 5, 0, Math.PI * 2);
                curveCtx.fill();

                curveCtx.strokeStyle = 'white';
                curveCtx.lineWidth = 2;
                curveCtx.stroke();
            });
        }

        curveCanvas.addEventListener('mousedown', (e) => {
            const rect = curveCanvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 255;
            const y = 255 - ((e.clientY - rect.top) / rect.height) * 255;

            for (let i = 0; i < curvePoints.length; i++) {
                const p = curvePoints[i];
                const dx = Math.abs(p.x - x);
                const dy = Math.abs(p.y - y);
                if (dx < 10 && dy < 10) {
                    selectedPoint = i;
                    isDraggingCurve = true;
                    return;
                }
            }

            if (x > 10 && x < 245) {
                curvePoints.push({x: Math.round(x), y: Math.round(y)});
                selectedPoint = curvePoints.length - 1;
                isDraggingCurve = true;
                updateCurveLUT();
            }
        });

        curveCanvas.addEventListener('mousemove', (e) => {
            if (!isDraggingCurve || selectedPoint === null) return;

            const rect = curveCanvas.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 255;
            const y = 255 - ((e.clientY - rect.top) / rect.height) * 255;

            if (selectedPoint === 0) {
                curvePoints[0].y = Math.max(0, Math.min(255, Math.round(y)));
            } else if (selectedPoint === curvePoints.length - 1) {
                curvePoints[selectedPoint].y = Math.max(0, Math.min(255, Math.round(y)));
            } else {
                curvePoints[selectedPoint].x = Math.max(0, Math.min(255, Math.round(x)));
                curvePoints[selectedPoint].y = Math.max(0, Math.min(255, Math.round(y)));
            }

            updateCurveLUT();
        });

        curveCanvas.addEventListener('mouseup', () => {
            isDraggingCurve = false;
        });

        curveCanvas.addEventListener('dblclick', (e) => {
            if (selectedPoint !== null && selectedPoint !== 0 && selectedPoint !== curvePoints.length - 1) {
                curvePoints.splice(selectedPoint, 1);
                selectedPoint = null;
                updateCurveLUT();
            }
        });

        function applyCurvePreset(preset) {
            switch (preset) {
                case 'linear':
                    curvePoints = [{x: 0, y: 0}, {x: 255, y: 255}];
                    break;
                case 'increase':
                    curvePoints = [{x: 0, y: 30}, {x: 255, y: 255}];
                    break;
                case 'decrease':
                    curvePoints = [{x: 0, y: 0}, {x: 255, y: 225}];
                    break;
                case 'contrast':
                    curvePoints = [{x: 0, y: 20}, {x: 128, y: 128}, {x: 255, y: 235}];
                    break;
                case 'sshape':
                    curvePoints = [{x: 0, y: 0}, {x: 64, y: 48}, {x: 192, y: 208}, {x: 255, y: 255}];
                    break;
            }
            selectedPoint = null;
            updateCurveLUT();
        }

        // ===== ç¼©ç•¥å›¾å¯¼èˆªåŠŸèƒ½ =====

        function toggleMinimap() {
            if (minimap.style.display === 'none') {
                minimap.style.display = 'block';
                positionMinimapNearButton();
                updateMinimap();
            } else {
                minimap.style.display = 'none';
            }
        }

        function positionMinimapNearButton() {
            // è·å–å¯¼èˆªæŒ‰é’®çš„ä½ç½®
            const navButton = document.querySelector('.toolbar .btn-secondary');
            if (navButton) {
                const rect = navButton.getBoundingClientRect();
                // å®šä½åœ¨æŒ‰é’®ä¸‹æ–¹ï¼Œç¨å¾®åå³
                minimap.style.left = (rect.left) + 'px';
                minimap.style.top = (rect.bottom + 10) + 'px';
            }
        }

        function updateMinimap() {
            if (!originalImage || minimap.style.display === 'none') return;

            const maxSize = 200;
            const imgW = originalImage.width;
            const imgH = originalImage.height;
            const minimapScale = Math.min(maxSize / imgW, maxSize / imgH);

            minimapCanvas.width = imgW * minimapScale;
            minimapCanvas.height = imgH * minimapScale;

            // ç»˜åˆ¶ç¼©ç•¥å›¾
            minimapCtx.drawImage(originalImage, 0, 0, minimapCanvas.width, minimapCanvas.height);

            // æ›´æ–°è§†å£ä½ç½®
            updateMinimapViewport();
        }

        function updateMinimapViewport() {
            if (!originalImage || minimap.style.display === 'none') return;

            const wrapper = canvasWrapper;
            const imgW = originalImage.width;
            const imgH = originalImage.height;
            const minimapScale = minimapCanvas.width / imgW;

            // è®¡ç®—å¯è§†åŒºåŸŸåœ¨åŸå›¾ä¸­çš„ä½ç½®å’Œå¤§å°
            const viewportW = wrapper.clientWidth / scale;
            const viewportH = wrapper.clientHeight / scale;
            const scrollX = (wrapper.scrollLeft - (canvasContainer.offsetWidth - canvas.width * scale) / 2) / scale;
            const scrollY = (wrapper.scrollTop - (canvasContainer.offsetHeight - canvas.height * scale) / 2) / scale;

            // åœ¨ç¼©ç•¥å›¾ä¸Šæ˜¾ç¤ºè§†å£
            const vpLeft = Math.max(0, scrollX * minimapScale);
            const vpTop = Math.max(0, scrollY * minimapScale);
            const vpWidth = Math.min(viewportW * minimapScale, minimapCanvas.width - vpLeft);
            const vpHeight = Math.min(viewportH * minimapScale, minimapCanvas.height - vpTop);

            minimapViewport.style.left = (vpLeft + 4) + 'px';
            minimapViewport.style.top = (vpTop + 4) + 'px';
            minimapViewport.style.width = vpWidth + 'px';
            minimapViewport.style.height = vpHeight + 'px';
        }

        // ç¼©ç•¥å›¾æ‹–åŠ¨ï¼ˆå…¨å±€èŒƒå›´ï¼‰
        minimapHeader.addEventListener('mousedown', (e) => {
            isMinimapDragging = true;
            const rect = minimap.getBoundingClientRect();
            minimapDragOffsetX = e.clientX - rect.left;
            minimapDragOffsetY = e.clientY - rect.top;
            e.preventDefault();
            e.stopPropagation();
        });

        document.addEventListener('mousemove', (e) => {
            if (isMinimapDragging) {
                const newLeft = e.clientX - minimapDragOffsetX;
                const newTop = e.clientY - minimapDragOffsetY;

                // é™åˆ¶åœ¨çª—å£èŒƒå›´å†…
                const maxLeft = window.innerWidth - minimap.offsetWidth;
                const maxTop = window.innerHeight - minimap.offsetHeight;

                minimap.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                minimap.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
            }
        });

        document.addEventListener('mouseup', () => {
            isMinimapDragging = false;
        });

        // ç¼©ç•¥å›¾ç‚¹å‡»è·³è½¬
        minimapCanvas.addEventListener('click', (e) => {
            const rect = minimapCanvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            const imgW = originalImage.width;
            const imgH = originalImage.height;
            const minimapScale = minimapCanvas.width / imgW;

            const targetX = (clickX / minimapScale) * scale;
            const targetY = (clickY / minimapScale) * scale;

            const wrapper = canvasWrapper;
            wrapper.scrollLeft = targetX - wrapper.clientWidth / 2 + (canvasContainer.offsetWidth - canvas.width * scale) / 2;
            wrapper.scrollTop = targetY - wrapper.clientHeight / 2 + (canvasContainer.offsetHeight - canvas.height * scale) / 2;

            updateMinimapViewport();
        });

        // ç›‘å¬æ»šåŠ¨å’Œç¼©æ”¾ï¼Œæ›´æ–°ç¼©ç•¥å›¾è§†å£
        canvasWrapper.addEventListener('scroll', updateMinimapViewport);

        loadImage();
        updateCurveLUT();
    </script>
</body>
</html>
